use super::token::{Token, TokenKind};
// use std::boxed;

#[derive(Debug, Clone, PartialEq)]
/// The types of literals a `Node::Literal` can have.
enum LiteralKind {
    String,
    Number,
    Boolean,
}

#[derive(Debug, Clone, PartialEq)]
/// Any sort of node that could appear inside a `Tree`.
enum Node {
    /// Any Sen value, like `"Hello world!"`, `false` or `3.14`.
    Literal(LiteralKind, String),

    /// A node that resolves to something else, but we don't know what yet.
    /// It could be a function or a variable, or it could just be an invalid
    /// identifier.
    Identifier(String),

    /// A node that points to another tree. `Box<Tree>` because
    /// structs cannot have recursive definitions, so something
    /// like
    /// ```
    /// Tree {
    ///     left: Node::Tree(Tree),
    ///     // ...
    /// }
    /// ```
    /// would be incorrect, or so I think. Either way it makes things
    /// make sense.
    Tree(Box<Tree>),

    /// A node which is empty and doesn't point to anything else.
    Null,
}

#[derive(Debug, Clone)]
/// A binary-tree-like structure that faithfully represents the S-expression
/// syntax of Sen (and Lisps as a whole). In order for the tree to be a syntactically
/// correct S-expression, `Tree.left` can only point to a terminal (`Node::Literal`,
/// `Node::Identifier`) or another tree (`Node::Tree`), and `Tree.right` can only point to
/// a null node (`Node::Null`) or another tree. AFAIK there is no way to represent that
/// with Rust type annotations, but even if there was, I don't think it would be needed
/// as we check if the expression being parsed is correct by ourselves.
pub struct Tree {
    left: Node,
    right: Node,
}

impl Tree {
    fn new() -> Tree {
        Tree {
            left: Node::Null,
            right: Node::Null,
        }
    }
    /// Whether at tree is a null tree: helper function that checks
    /// whether the result of `Parser.parse_sexpr()` is a null
    /// terminal, or null node. Ideally we'd return a `Node::Null`, but the type
    /// signature of `Parser.parse_sexpr()` is `Tree`, not `Node`.
    fn is_null(&self) -> bool {
        self.left == Node::Null && self.right == Node::Null
    }
}

/// Allows us to derive `PartialEq` for `Node`.
impl PartialEq for Box<Tree> {
    fn eq(&self, rhs: &Box<Tree>) -> bool {
        (*self).left == (*rhs).left && (*self).right == (*rhs).right
    }
    fn ne(&self, rhs: &Box<Tree>) -> bool {
        !self.eq(rhs)
    }
}

/// Parser which takes in a vector of tokens and returns a vector of
/// `Tree`s.
pub struct Parser<'a> {
    /// List of input tokens (generated by lexer)
    tokens: &'a Vec<Token>,

    /// The token currently being processed
    current: usize,

    /// Result of parsing, a vector of statements (each has a tree structure)
    result: Vec<Tree>,
}

impl<'a> Parser<'a> {
    pub fn new(tokens: &'a Vec<Token>) -> Parser<'a> {
        Parser {
            tokens,
            current: 0,
            result: Vec::new(),
        }
    }

    /// Fetches the current token being pointed to by `Parser.current`
    /// (if there is such a token).
    fn get_current(&self) -> Option<&Token> {
        if self.is_past_end() {
            return None;
        }
        Some(&self.tokens[self.current])
    }

    /// Advances one token forward and returns the new current.
    fn advance(&mut self) -> Option<&Token> {
        self.current += 1;
        self.get_current()
    }

    /// Whether the `Parser.current` pointer is no longer pointing to
    /// a valid token in the input.
    fn is_past_end(&self) -> bool {
        self.current >= self.tokens.len()
    }

    /// Parses a single expression (not just S-expression!) so one of:
    /// - a literal,
    /// - an identifier,
    /// - a null node,
    /// - an S-expression (simply calls `Parser.parse_sexpr()`).
    fn parse_expr(&mut self) -> Node {
        let t = self.get_current();
        if t.is_none() {
            panic!("WTF?!");
        }
        match &t.unwrap().kind {
            TokenKind::String(v) => Node::Literal(LiteralKind::String, v.to_owned()),

            TokenKind::Number(v) => Node::Literal(LiteralKind::Number, v.to_owned()),

            TokenKind::True => Node::Literal(LiteralKind::Boolean, String::from("true")),

            TokenKind::False => Node::Literal(LiteralKind::Boolean, String::from("false")),

            TokenKind::Identifier(v) => Node::Identifier(v.to_owned()),

            TokenKind::LeftParen => {
                self.advance();
                let node = self.parse_sexpr();
                Node::Tree(Box::new(node))
            }

            TokenKind::RightParen => Node::Null,

            _ => Node::Null, // implement error
        }
    }

    /// Parses an S-expression and returns its signature in the form of a `Tree`.
    fn parse_sexpr(&mut self) -> Tree {
        let mut tree = Tree::new();

        if let Some(t) = self.get_current() {
            if t.kind == TokenKind::RightParen {
                tree.left = Node::Null;
                tree.right = Node::Null;
                return tree;
            }
        }

        tree.left = self.parse_expr();
        self.advance(); // past expression
        let r = self.parse_sexpr();
        if r.is_null() {
            tree.right = Node::Null;
        } else {
            tree.right = Node::Tree(Box::new(r));
        }

        match self.get_current() {
            Some(tok) if tok.kind == TokenKind::RightParen || tok.kind == TokenKind::EOF => tree,

            _ => panic!("Oops! I expected a closing parenthesis after a sexpr"),
        }
    }

    /// Runs the parser and returns its result.
    pub fn run(&'a mut self) -> Result<&'a Vec<Tree>, String> {
        loop {
            let t = self.get_current();
            if t.is_none() {
                break;
            }
            match t.unwrap().kind {
                TokenKind::EOF => break,
                TokenKind::LeftParen => {
                    self.advance(); // past left paren
                    let tree = self.parse_sexpr();
                    self.result.push(tree);
                }

                _ => panic!("WTH? I wanted a left paren or at least an EOF!"),
            }
            self.advance();
        }

        Ok(&self.result)
    }
}
